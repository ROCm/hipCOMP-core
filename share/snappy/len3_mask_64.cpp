/*
 * Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// MIT License
// 
// Modifications Copyright (c) 2023-2024 Advanced Micro Devices, Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <iostream>
#include <stdint.h>
 
static const uint8_t k_len3lut[1 << 10] = {
  0x80, 0x91, 0x80, 0x91, 0x92, 0x91, 0x92, 0x91, 0x80, 0xa3, 0x80, 0xa3, 0x92, 0xa3, 0x92, 0xa3,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xa3, 0x94, 0xa3, 0x92, 0xa3, 0x92, 0xa3,
  0x80, 0xa5, 0x80, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x80, 0xa3, 0x80, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0x94, 0xa5, 0x94, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x94, 0xa3, 0x94, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0x98, 0x91, 0x98, 0x91, 0x92, 0x91, 0x92, 0x91, 0x98, 0xb7, 0x98, 0xb7, 0x92, 0xb7, 0x92, 0xb7,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xb7, 0x94, 0xb7, 0x92, 0xb7, 0x92, 0xb7,
  0x98, 0xa5, 0x98, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x98, 0xb7, 0x98, 0xb7, 0xa6, 0xb7, 0xa6, 0xb7,
  0x94, 0xa5, 0x94, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x94, 0xb7, 0x94, 0xb7, 0xa6, 0xb7, 0xa6, 0xb7,
  0x80, 0xa9, 0x80, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x80, 0xa3, 0x80, 0xa3, 0xaa, 0xa3, 0xaa, 0xa3,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xa3, 0xac, 0xa3, 0xaa, 0xa3, 0xaa, 0xa3,
  0x80, 0xa5, 0x80, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x80, 0xa3, 0x80, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0xac, 0xa5, 0xac, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0xac, 0xa3, 0xac, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0x98, 0xa9, 0x98, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x98, 0xb7, 0x98, 0xb7, 0xaa, 0xb7, 0xaa, 0xb7,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xb7, 0xac, 0xb7, 0xaa, 0xb7, 0xaa, 0xb7,
  0x98, 0xa5, 0x98, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x98, 0xb7, 0x98, 0xb7, 0xa6, 0xb7, 0xa6, 0xb7,
  0xac, 0xa5, 0xac, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0xac, 0xb7, 0xac, 0xb7, 0xa6, 0xb7, 0xa6, 0xb7,
  0x80, 0x91, 0x80, 0x91, 0x92, 0x91, 0x92, 0x91, 0x80, 0xbb, 0x80, 0xbb, 0x92, 0xbb, 0x92, 0xbb,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xbb, 0x94, 0xbb, 0x92, 0xbb, 0x92, 0xbb,
  0x80, 0xbd, 0x80, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x80, 0xbb, 0x80, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0x94, 0xbd, 0x94, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x94, 0xbb, 0x94, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0x98, 0x91, 0x98, 0x91, 0x92, 0x91, 0x92, 0x91, 0x98, 0xb7, 0x98, 0xb7, 0x92, 0xb7, 0x92, 0xb7,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xb7, 0x94, 0xb7, 0x92, 0xb7, 0x92, 0xb7,
  0x98, 0xbd, 0x98, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x98, 0xb7, 0x98, 0xb7, 0xbe, 0xb7, 0xbe, 0xb7,
  0x94, 0xbd, 0x94, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x94, 0xb7, 0x94, 0xb7, 0xbe, 0xb7, 0xbe, 0xb7,
  0x80, 0xa9, 0x80, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x80, 0xbb, 0x80, 0xbb, 0xaa, 0xbb, 0xaa, 0xbb,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xbb, 0xac, 0xbb, 0xaa, 0xbb, 0xaa, 0xbb,
  0x80, 0xbd, 0x80, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x80, 0xbb, 0x80, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0xac, 0xbd, 0xac, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0xac, 0xbb, 0xac, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0x98, 0xa9, 0x98, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x98, 0xb7, 0x98, 0xb7, 0xaa, 0xb7, 0xaa, 0xb7,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xb7, 0xac, 0xb7, 0xaa, 0xb7, 0xaa, 0xb7,
  0x98, 0xbd, 0x98, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x98, 0xb7, 0x98, 0xb7, 0xbe, 0xb7, 0xbe, 0xb7,
  0xac, 0xbd, 0xac, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0xac, 0xb7, 0xac, 0xb7, 0xbe, 0xb7, 0xbe, 0xb7,
  0x80, 0x91, 0x80, 0x91, 0x92, 0x91, 0x92, 0x91, 0x80, 0xa3, 0x80, 0xa3, 0x92, 0xa3, 0x92, 0xa3,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xa3, 0x94, 0xa3, 0x92, 0xa3, 0x92, 0xa3,
  0x80, 0xa5, 0x80, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x80, 0xa3, 0x80, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0x94, 0xa5, 0x94, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x94, 0xa3, 0x94, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0x98, 0x91, 0x98, 0x91, 0x92, 0x91, 0x92, 0x91, 0x98, 0xcf, 0x98, 0xcf, 0x92, 0xcf, 0x92, 0xcf,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xcf, 0x94, 0xcf, 0x92, 0xcf, 0x92, 0xcf,
  0x98, 0xa5, 0x98, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x98, 0xcf, 0x98, 0xcf, 0xa6, 0xcf, 0xa6, 0xcf,
  0x94, 0xa5, 0x94, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x94, 0xcf, 0x94, 0xcf, 0xa6, 0xcf, 0xa6, 0xcf,
  0x80, 0xa9, 0x80, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x80, 0xa3, 0x80, 0xa3, 0xaa, 0xa3, 0xaa, 0xa3,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xa3, 0xac, 0xa3, 0xaa, 0xa3, 0xaa, 0xa3,
  0x80, 0xa5, 0x80, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x80, 0xa3, 0x80, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0xac, 0xa5, 0xac, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0xac, 0xa3, 0xac, 0xa3, 0xa6, 0xa3, 0xa6, 0xa3,
  0x98, 0xa9, 0x98, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x98, 0xcf, 0x98, 0xcf, 0xaa, 0xcf, 0xaa, 0xcf,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xcf, 0xac, 0xcf, 0xaa, 0xcf, 0xaa, 0xcf,
  0x98, 0xa5, 0x98, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0x98, 0xcf, 0x98, 0xcf, 0xa6, 0xcf, 0xa6, 0xcf,
  0xac, 0xa5, 0xac, 0xa5, 0xa6, 0xa5, 0xa6, 0xa5, 0xac, 0xcf, 0xac, 0xcf, 0xa6, 0xcf, 0xa6, 0xcf,
  0x80, 0x91, 0x80, 0x91, 0x92, 0x91, 0x92, 0x91, 0x80, 0xbb, 0x80, 0xbb, 0x92, 0xbb, 0x92, 0xbb,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xbb, 0x94, 0xbb, 0x92, 0xbb, 0x92, 0xbb,
  0x80, 0xbd, 0x80, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x80, 0xbb, 0x80, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0x94, 0xbd, 0x94, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x94, 0xbb, 0x94, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0x98, 0x91, 0x98, 0x91, 0x92, 0x91, 0x92, 0x91, 0x98, 0xcf, 0x98, 0xcf, 0x92, 0xcf, 0x92, 0xcf,
  0x94, 0x91, 0x94, 0x91, 0x92, 0x91, 0x92, 0x91, 0x94, 0xcf, 0x94, 0xcf, 0x92, 0xcf, 0x92, 0xcf,
  0x98, 0xbd, 0x98, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x98, 0xcf, 0x98, 0xcf, 0xbe, 0xcf, 0xbe, 0xcf,
  0x94, 0xbd, 0x94, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x94, 0xcf, 0x94, 0xcf, 0xbe, 0xcf, 0xbe, 0xcf,
  0x80, 0xa9, 0x80, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x80, 0xbb, 0x80, 0xbb, 0xaa, 0xbb, 0xaa, 0xbb,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xbb, 0xac, 0xbb, 0xaa, 0xbb, 0xaa, 0xbb,
  0x80, 0xbd, 0x80, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x80, 0xbb, 0x80, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0xac, 0xbd, 0xac, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0xac, 0xbb, 0xac, 0xbb, 0xbe, 0xbb, 0xbe, 0xbb,
  0x98, 0xa9, 0x98, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0x98, 0xcf, 0x98, 0xcf, 0xaa, 0xcf, 0xaa, 0xcf,
  0xac, 0xa9, 0xac, 0xa9, 0xaa, 0xa9, 0xaa, 0xa9, 0xac, 0xcf, 0xac, 0xcf, 0xaa, 0xcf, 0xaa, 0xcf,
  0x98, 0xbd, 0x98, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0x98, 0xcf, 0x98, 0xcf, 0xbe, 0xcf, 0xbe, 0xcf,
  0xac, 0xbd, 0xac, 0xbd, 0xbe, 0xbd, 0xbe, 0xbd, 0xac, 0xcf, 0xac, 0xcf, 0xbe, 0xcf, 0xbe, 0xcf};  

typedef uint64_t lane_mask_t;
 
#define lo4(m4) ((m4) & 0xf)
#define hi4(m4) ((m4) >> 4)
#define lo10(v) ((v) & 0x3ff)
#define lo_n(v) ((v) & ((1lu << n) - 1))
/**
 * @brief Returns a 64-bit mask where 1 means 3-byte code length and 0 means 2-byte
 * code length, given an input mask of up to 192 bits.
 *
 * Implemented by doing 16 consecutive lookups, building the result 4-bit at a time.
 *
 * Each lookup reads 10 bits from v0+v1+v2 and passes them to the k_len3lut lookup table.
 * The 8-bit lookup table entries encodes a 4-bit mask about the length of the next 4 LZ77 symbols (1: 3 bytes, 0: 2 bytes)
 * in the lower 4 bits and the aggregated length of the 4 LZ77 symbols (in bytes) in its upper 4 bits.
 * As four 2-bytes symbols would have a length of 0=0b0000 while four 3-bytes symbols would have a length of 12=0b1100=0xc,
 * the possible aggregated lengths are 8 ... 12 (0x8 ... 0xc).
 *
 * The lookup then adds the 4 mask bits to result mask and shifts the input registers v0+v1+v2 by the
 * aggregrated symbol length.
 *
 * The whole process consumes 120 .. 180 bits of the three input registers v0+v1+v2.
 **/
lane_mask_t get_len3_mask(lane_mask_t v0, lane_mask_t v1, lane_mask_t v2)
{
  lane_mask_t m; // result
  lane_mask_t m4;
  uint64_t v;
  uint32_t n;
  uint32_t _n_total = 0;
 
  v  = v0;
  // Five lookups within register v=v0:
  m4 = k_len3lut[lo10(v)];
  m  = lo4(m4);
  n  = hi4(m4);
  v  = v0 >> n; // 8 .. 12
  for (int i = 1; i < 5; i++) { // 40 .. 60
    m4 = k_len3lut[lo10(v)];
    m  |= lo4(m4) << (i*4);
    n  += hi4(m4);
    v = v0 >> n;
  }
  // State:
  // * m: 20=5*4 bits written at this stage
  // * n=40 .. 60 orig. v0 bits consumed
 
  // Shift across register boundaries v(v0) <-> v1 and v1 <-> v2:
  v |= lo_n(v1) << (64-n); // n=40...60
  v0 = v;
  v1 >>= n;
  v1 |= lo_n(v2) << (64-n);
  v2 >>= n;
  // State:
  // * v/v0 is now a mix of 24 .. 4 bits from orig. v0 and 40 .. 60 bits from orig. v1
  // * v1 is now a mix of 24 .. 4 bits from orig. v1 and 40 .. 60 bits from orig. v2
 
  // Five lookups within register v
  _n_total += n;
  n = 0;
  for (int i = 5; i < 10; i++) { // 40 .. 60
    m4 = k_len3lut[lo10(v)];
    m  |= lo4(m4) << (i*4);
    n  += hi4(m4);
    v = v0 >> n;
  }
  // State:
  // * m: 40=2*5*4 bits written at this stage
  // * 80 .. 120 v0+v1 bits consumed:
  //   * All 64 orig. v0 bits consumed
  //   * 16 .. 56 orig. v1 bits consumed
 
  // Shift across register boundaries v(v1) <-> v1(v1,v2) and v1(v1,v2) <-> v2:
  v |= lo_n(v1) << (64-n); // n = 40 .. 60
  v0 = v;
  v1 >>= n;
  v1 |= lo_n(v2) << (64-n);
  // State:
  // * v/v0 is now a mix of 8 .. 48 bits from orig. v1 plus 56 .. 16 bits from orig. v2
  // * v1 now contains 8 .. 48 bits from orig. v2
  // Implication:
  // * All orig. v2 bits have been shifted to v1 and v/v0. Thus, var v2 can be ignored
  //   from now on.
  _n_total += n;
  n = 0;
  for (int i = 10; i < 15; i++) { // 40 .. 60
    m4 = k_len3lut[lo10(v)];
    m  |= lo4(m4) << (i*4);
    n  += hi4(m4);
    v = v0 >> n;
  }
  // 60=3*5*4 m bits written at this stage
  // 120 .. 180 v0+v1/v0+v1+v2 bits consumed at this stage
  _n_total += n; 
  std::cout << "consumed_bits (pre last)=" << _n_total << std::endl;
  v |= lo_n(v1) << (64-n); // n = 40 .. 60
  constexpr int i = 15;
  m4 = k_len3lut[lo10(v)];
  std::cout << "last m4=" << m4 << std::endl;
  m  |= lo4(m4) << (i*4); // write last 4 bits
  return m;
}
#undef lo4
#undef hi4
#undef lo10
#undef lo_n
 
int main(int argc, char** argv) {
  uint64_t v0,v1,v2;
  lane_mask_t len3_mask, len3_mask_expected;
 
  // Batch Test 2: cur_t: 141
 
  v0=1297045497366774530lu;
  v1=306244775751782400lu;
  v2=9800413331314508032lu;
 
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
  if ( len3_mask != 0b0000000000000000000000000000000000100000000000010000000000010000lu ) {
    std::cout << "0: cur_t: 141 - FAIL" << std::endl;
  }
 
  // Batch Test 2: cur_t: 172
 
  v0=1225051666414313504lu;
  v1=1157429502285062340lu;
  v2=9223381383253332224lu;
 
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != 4432414638080lu ) {
    std::cout << "1: cur_t: 172 - FAIL" << std::endl;
  }

  // app input 2: cur_t: 0
  v0 = 15995499993133274059lu;
  v1 = 17575218449657001922lu;
  v2 = 13172742451556175867lu;

  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != 18157369724142337727lu ) {
    std::cout << "2: cur_t: 0 - FAIL" << std::endl;
  }

  // trivial tests
  v0 = 0lu;
  v1 = 0lu;
  v2 = 0lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
  if ( len3_mask != 0lu ) {
    std::cout << "trivial test 0: FAIL" << std::endl;
  }

  v0 = ~0lu;
  v1 = ~0lu;
  v2 = ~0lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
  if ( len3_mask != ~0lu ) {
    std::cout << "trivial test 1: FAIL" << std::endl;
  }

  // Random values generated via len3_mask.py script
 
  // random values test 0
  v0=7758176404715800194lu;
  v1=15308084094301570617lu;
  v2=8791662011684601223lu;
  len3_mask_expected = 11445179411786116384lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != len3_mask_expected ) {
    std::cout << "random values test 0: FAIL" << std::endl;
  }
 
  // random values test 1
  v0=9309829342914403545lu;
  v1=5721212930748269353lu;
  v2=12617276543794194196lu;
  len3_mask_expected = 7791782604716717943lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != len3_mask_expected ) {
    std::cout << "random values test 1: FAIL" << std::endl;
  }
 
  // random values test 2
  v0=10326739782786242647lu;
  v1=8009056699280396679lu;
  v2=4805234989534244506lu;
  len3_mask_expected = 5620369564699159521lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != len3_mask_expected ) {
    std::cout << "random values test 2: FAIL" << std::endl;
  }
 
  // random values test 3
  v0=259023674760142153lu;
  v1=15496947691660677356lu;
  v2=11534118754833929857lu;
  len3_mask_expected = 7532076208157512087lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != len3_mask_expected ) {
    std::cout << "random values test 3: FAIL" << std::endl;
  }
 
  // random values test 4
  v0=6145258598325499690lu;
  v1=1161854816982873064lu;
  v2=10468725429203222863lu;
  len3_mask_expected = 7229541556309993936lu;
  len3_mask = get_len3_mask(v0,v1,v2);
  std::cout << len3_mask << std::endl;
 
  if ( len3_mask != len3_mask_expected ) {
    std::cout << "random values test 4: FAIL" << std::endl;
  }
}